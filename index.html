<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Price Chart</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }
    
    body {
      background-color: #111827;
      color: #F3F4F6;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
      position: relative;
    }
    
    .github-link {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: 32px;
      height: 32px;
      color: #F3F4F6;
      transition: color 0.2s;
      z-index: 100;
    }
    
    .github-link:hover {
      color: #F7931A;
    }
    
    .search-container {
      margin: 2rem auto 1rem auto;
      max-width: 600px;
      width: 100%;
    }
    
    .search-form {
      display: flex;
      width: 100%;
      position: relative;
    }
    
    .search-input {
      flex: 1;
      padding: 0.75rem 1rem;
      border-radius: 2rem;
      border: 1px solid #374151;
      background-color: #1F2937;
      color: #F3F4F6;
      font-size: 1rem;
      outline: none;
      transition: all 0.2s;
      padding-right: 3rem;
    }
    
    .search-input:focus {
      border-color: #F7931A;
      box-shadow: 0 0 0 2px rgba(247, 147, 26, 0.25);
    }
    
    .search-input::placeholder {
      color: #6B7280;
    }
    
    .search-button {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #6B7280;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .search-button:hover {
      color: #F7931A;
      background-color: rgba(247, 147, 26, 0.1);
    }
    
    .chart-container {
      border-radius: 0.5rem;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      background-color: #1F2937;
      margin: 1rem auto 2rem auto;
      width: 100%;
    }
    
    .chart-header {
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }
    
    .header-content {
      display: flex;
      flex-direction: column;
    }
    
    .chart-title {
      display: flex;
      align-items: center;
      font-size: 1.25rem;
      font-weight: bold;
      color: white;
      margin: 0 0 1rem 0;
    }
    
    .chart-title svg {
      margin-right: 0.5rem;
    }
    
    .time-intervals {
      display: flex;
      align-items: center;
      background-color: #374151;
      border-radius: 0.5rem;
      padding: 0.25rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .interval-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background: none;
      border: none;
      cursor: pointer;
      transition: all 0.15s ease;
      white-space: nowrap;
    }
    
    .interval-btn.active {
      background-color: #F7931A;
      color: white;
      font-weight: 500;
    }
    
    .interval-btn:not(.active) {
      color: #9CA3AF;
    }
    
    .interval-btn:not(.active):hover {
      color: white;
    }
    
    .chart-body {
      position: relative;
      padding: 1rem;
    }
    
    .price-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    
    .price-label {
      color: #9CA3AF;
      font-size: 0.875rem;
    }
    
    .price-value {
      display: flex;
      align-items: center;
      font-size: 1.25rem;
      font-weight: bold;
      color: white;
    }
    
    .price-change {
      margin-left: 0.5rem;
      font-size: 0.875rem;
      font-weight: normal;
    }
    
    .price-change.positive {
      color: #10B981;
    }
    
    .price-change.negative {
      color: #EF4444;
    }
    
    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 400px;
      margin-bottom: 1rem;
    }
    
    #mainChart {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    #rangeSelector {
      width: 100%;
      height: 60px;
      cursor: grab;
    }
    
    .tooltip {
      position: absolute;
      background-color: #374151;
      border: 1px solid #4B5563;
      border-radius: 0.375rem;
      padding: 0.75rem;
      pointer-events: none;
      display: none;
      z-index: 10;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    
    .tooltip-date {
      font-size: 0.75rem;
      color: #D1D4DC;
      margin: 0 0 0.5rem 0;
    }
    
    .tooltip-price {
      font-size: 1.125rem;
      font-weight: bold;
      color: white;
      margin: 0 0 0.5rem 0;
    }
    
    .tooltip-extra {
      font-size: 0.75rem;
      color: #9CA3AF;
      margin: 0;
    }
    
    .range-handles {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      pointer-events: none;
    }
    
    .range-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 60px;
      background-color: #F7931A;
      border-radius: 4px;
      cursor: col-resize;
      pointer-events: all;
      touch-action: none;
    }
    
    .range-selected {
      position: absolute;
      top: 0;
      height: 60px;
      background-color: rgba(247, 147, 26, 0.2);
      pointer-events: none;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(31, 41, 55, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #F7931A;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .chart-footer {
      margin-top: 1rem;
      color: #6B7280;
      font-size: 0.75rem;
    }
    
    .tip-jar {
      margin: 2rem auto;
      max-width: 600px;
      text-align: center;
      width: 100%;
    }
    
    .tip-jar-title {
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: #F7931A;
    }
    
    .tip-address-container {
      background-color: #1F2937;
      border-radius: 0.5rem;
      padding: 1rem;
      border: 1px solid #374151;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .tip-address {
      font-family: monospace;
      font-size: 1rem;
      color: #D1D4DC;
      overflow-wrap: break-word;
      text-align: center;
      margin-right: 10px;
    }
    
    .copy-button {
      background-color: #374151;
      border: none;
      color: #D1D4DC;
      width: 36px;
      height: 36px;
      border-radius: 0.375rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    
    .copy-button:hover {
      background-color: #4B5563;
      color: white;
    }
    
    .copy-button:active {
      transform: scale(0.95);
    }
    
    .copy-success {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #059669;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .copy-success.show {
      opacity: 1;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Responsive adjustments */
    @media (min-width: 640px) {
      .header-content {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      
      .chart-title {
        margin-bottom: 0;
      }
    }
    
    @media (max-width: 639px) {
      .chart-wrapper {
        height: 300px;
      }
      
      .time-intervals {
        justify-content: space-between;
      }
      
      .interval-btn {
        padding: 0.5rem;
        font-size: 0.75rem;
      }
      
      .price-info {
        margin-top: 0.5rem;
      }
      
      .price-value {
        font-size: 1.125rem;
      }
      
      .tip-address-container {
        flex-direction: column;
      }
      
      .tip-address {
        margin-right: 0;
        margin-bottom: 10px;
        font-size: 0.875rem;
      }
    }
    
    @media (max-width: 480px) {
      .chart-wrapper {
        height: 250px;
      }
      
      .chart-title {
        font-size: 1rem;
      }
      
      .interval-btn {
        padding: 0.25rem 0.5rem;
      }
      
      .chart-header, .chart-body {
        padding: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <a href="https://github.com/Saganaki22/BTC" class="github-link" title="View on GitHub">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
    </svg>
  </a>
  
  <div class="container">
    <div class="search-container">
      <form id="searchForm" class="search-form">
        <input 
          type="text" 
          id="searchInput" 
          class="search-input" 
          placeholder="Search for wallet address or transaction ID..." 
          autocomplete="off"
          spellcheck="false"
        >
        <button type="submit" class="search-button" title="Search mempool.space">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
        </button>
      </form>
    </div>
    
    <div class="chart-container">
      <div class="chart-header">
        <div class="header-content">
          <h2 class="chart-title">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 4091.27 4091.73">
              <g>
                <path fill="#F7931A" fill-rule="nonzero" d="M4030.06 2540.77c-273.24,1096.01 -1383.32,1763.02 -2479.46,1489.71 -1095.68,-273.24 -1762.69,-1383.39 -1489.33,-2479.31 273.12,-1096.13 1383.2,-1763.19 2479,-1489.95 1096.06,273.24 1763.03,1383.51 1489.76,2479.57l0.02 -0.02z"></path>
                <path fill="white" fill-rule="nonzero" d="M2947.77 1754.38c40.72,-272.26 -166.56,-418.61 -450,-516.24l91.95 -368.8 -224.5 -55.94 -89.51 359.09c-59.02,-14.72 -119.63,-28.59 -179.87,-42.34l90.16 -361.46 -224.36 -55.94 -92 368.68c-48.84,-11.12 -96.81,-22.11 -143.35,-33.69l0.26 -1.16 -309.59 -77.31 -59.72 239.78c0,0 166.56,38.18 163.05,40.53 90.91,22.69 107.35,82.87 104.62,130.57l-104.74 420.15c6.26,1.59 14.38,3.89 23.34,7.49 -7.49,-1.86 -15.46,-3.89 -23.73,-5.87l-146.81 588.57c-11.11,27.62 -39.31,69.07 -102.87,53.33 2.25,3.26 -163.17,-40.72 -163.17,-40.72l-111.46 256.98 292.15 72.83c54.35,13.63 107.61,27.89 160.06,41.3l-92.9 373.03 224.24 55.94 92 -369.07c61.26,16.63 120.71,31.97 178.91,46.43l-91.69 367.33 224.51 55.94 92.89 -372.33c382.82,72.45 670.67,43.24 791.83,-303.02 97.63,-278.78 -4.86,-439.58 -206.26,-544.44 146.69,-33.83 257.18,-130.31 286.64,-329.61l-0.07 -0.05zm-512.93 719.26c-69.38,278.78 -538.76,128.08 -690.94,90.29l123.28 -494.2c152.17,37.99 640.17,113.17 567.67,403.91zm69.43 -723.3c-63.29,253.58 -453.96,124.75 -580.69,93.16l111.77 -448.21c126.73,31.59 534.85,90.55 468.94,355.05l-0.02 0z"></path>
              </g>
            </svg>
            Bitcoin Price Chart
          </h2>
          <div class="time-intervals">
            <button class="interval-btn" data-interval="1D">1D</button>
            <button class="interval-btn active" data-interval="7D">7D</button>
            <button class="interval-btn" data-interval="1M">1M</button>
            <button class="interval-btn" data-interval="1Y">1Y</button>
            <button class="interval-btn" data-interval="ALL">ALL</button>
          </div>
        </div>
      </div>
      
      <div class="chart-body">
        <div id="loadingOverlay" class="loading-overlay">
          <div class="spinner"></div>
        </div>
        
        <div class="price-info">
          <div class="price-label">Price (USD)</div>
          <div class="price-value">
            $<span id="currentPrice">0.00</span>
            <span id="priceChange" class="price-change">+0.00%</span>
          </div>
        </div>
        
        <div class="chart-wrapper">
          <canvas id="mainChart"></canvas>
          <div id="tooltip" class="tooltip">
            <p class="tooltip-date"></p>
            <p class="tooltip-price"></p>
            <p class="tooltip-extra"></p>
            <p class="tooltip-extra"></p>
          </div>
        </div>
        
        <div class="chart-wrapper" style="height: 60px;">
          <canvas id="rangeSelector"></canvas>
          <div class="range-handles">
            <div class="range-selected"></div>
            <div class="range-handle" id="leftHandle"></div>
            <div class="range-handle" id="rightHandle"></div>
          </div>
        </div>
        
        <div class="chart-footer">
          Data sourced from CoinGecko API â€¢ Last updated: <span id="lastUpdated"></span>
        </div>
      </div>
    </div>
    
    <div class="tip-jar">
      <h3 class="tip-jar-title">Tip Jar</h3>
      <div class="tip-address-container">
        <div class="tip-address">bc1qlp5urduycv8kaynym0z6cvgqwk7frxr8vk489a</div>
        <button class="copy-button" id="copyButton" title="Copy address">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
        <div class="copy-success" id="copySuccess">Copied!</div>
      </div>
    </div>
  </div>

  <script>
    // Bitcoin Chart Application
    (function() {
      // DOM Elements
      const mainChart = document.getElementById('mainChart');
      const rangeSelector = document.getElementById('rangeSelector');
      const tooltip = document.getElementById('tooltip');
      const currentPrice = document.getElementById('currentPrice');
      const priceChange = document.getElementById('priceChange');
      const lastUpdated = document.getElementById('lastUpdated');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const leftHandle = document.getElementById('leftHandle');
      const rightHandle = document.getElementById('rightHandle');
      const rangeSelected = document.querySelector('.range-selected');
      const intervalButtons = document.querySelectorAll('.interval-btn');
      const copyButton = document.getElementById('copyButton');
      const copySuccess = document.getElementById('copySuccess');
      const searchForm = document.getElementById('searchForm');
      const searchInput = document.getElementById('searchInput');
      
      // Set up clipboard functionality
      copyButton.addEventListener('click', function() {
        const address = 'bc1qlp5urduycv8kaynym0z6cvgqwk7frxr8vk489a';
        navigator.clipboard.writeText(address).then(function() {
          copySuccess.classList.add('show');
          setTimeout(function() {
            copySuccess.classList.remove('show');
          }, 2000);
        });
      });
      
      // Set up search functionality
      searchForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const query = searchInput.value.trim();
        
        if (!query) return;
        
        let url;
        
        // Basic validation for Bitcoin address format
        // This is a very simple check and not comprehensive
        if (query.startsWith('bc1') || query.startsWith('1') || query.startsWith('3')) {
          url = `https://mempool.space/address/${query}`;
        } else {
          // Treat as transaction ID by default
          url = `https://mempool.space/tx/${query}`;
        }
        
        window.open(url, '_blank');
      });
      
      // Chart settings
      const settings = {
        mainCtx: mainChart.getContext('2d'),
        rangeCtx: rangeSelector.getContext('2d'),
        darkTheme: {
          backgroundColor: '#1F2937',
          gridColor: '#374151',
          textColor: '#D1D4DC',
          lineColor: '#F7931A',
          areaColor: 'rgba(247, 147, 26, 0.2)',
          referenceLineColor: '#10B981'
        },
        padding: { top: 20, right: 60, bottom: 30, left: 70 },
        rangePadding: { top: 5, right: 60, bottom: 5, left: 70 },
        activeInterval: '7D',
        chartData: [],
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        isDragging: false,
        draggedHandle: null,
        mouseMoveThrottleId: null,
        touchStartX: 0
      };
      
      // Initialize chart
      function initChart() {
        updateCanvasSize();
        setupEventListeners();
        loadChartData('7D');
        lastUpdated.textContent = new Date().toLocaleString();
      }
      
      // Update canvas size based on container
      function updateCanvasSize() {
        const dpr = window.devicePixelRatio || 1;
        
        // Main chart
        const mainRect = mainChart.getBoundingClientRect();
        mainChart.width = mainRect.width * dpr;
        mainChart.height = mainRect.height * dpr;
        settings.mainCtx.scale(dpr, dpr);
        
        // Range selector
        const rangeRect = rangeSelector.getBoundingClientRect();
        rangeSelector.width = rangeRect.width * dpr;
        rangeSelector.height = rangeRect.height * dpr;
        settings.rangeCtx.scale(dpr, dpr);
      }
      
      // Set up event listeners
      function setupEventListeners() {
        // Resize listener
        window.addEventListener('resize', function() {
          updateCanvasSize();
          if (settings.chartData.length > 0) {
            drawMainChart();
            drawRangeChart();
            updateRangeHandles();
          }
        });
        
        // Interval buttons
        intervalButtons.forEach(button => {
          button.addEventListener('click', function() {
            intervalButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            settings.activeInterval = this.dataset.interval;
            loadChartData(settings.activeInterval);
          });
        });
        
        // Mouse interaction with main chart
        mainChart.addEventListener('mousemove', throttle(function(e) {
          handleChartInteraction(e.clientX, e.clientY);
        }, 30));
        
        // Touch interaction with main chart
        mainChart.addEventListener('touchmove', throttle(function(e) {
          if (e.touches && e.touches[0]) {
            handleChartInteraction(e.touches[0].clientX, e.touches[0].clientY);
          }
        }, 30));
        
        mainChart.addEventListener('mouseleave', function() {
          tooltip.style.display = 'none';
          drawMainChart();
        });
        
        mainChart.addEventListener('touchend', function() {
          tooltip.style.display = 'none';
          drawMainChart();
        });
        
        // Range selector mouse events
        leftHandle.addEventListener('mousedown', function(e) {
          e.preventDefault();
          settings.isDragging = true;
          settings.draggedHandle = 'left';
        });
        
        rightHandle.addEventListener('mousedown', function(e) {
          e.preventDefault();
          settings.isDragging = true;
          settings.draggedHandle = 'right';
        });
        
        // Range selector touch events
        leftHandle.addEventListener('touchstart', function(e) {
          if (e.touches && e.touches[0]) {
            e.preventDefault();
            settings.isDragging = true;
            settings.draggedHandle = 'left';
            settings.touchStartX = e.touches[0].clientX;
          }
        });
        
        rightHandle.addEventListener('touchstart', function(e) {
          if (e.touches && e.touches[0]) {
            e.preventDefault();
            settings.isDragging = true;
            settings.draggedHandle = 'right';
            settings.touchStartX = e.touches[0].clientX;
          }
        });
        
        // Mouse move for range selector
        document.addEventListener('mousemove', function(e) {
          if (!settings.isDragging || !settings.draggedHandle) return;
          handleRangeHandleDrag(e.clientX);
        });
        
        // Touch move for range selector
        document.addEventListener('touchmove', function(e) {
          if (!settings.isDragging || !settings.draggedHandle || !e.touches || !e.touches[0]) return;
          handleRangeHandleDrag(e.touches[0].clientX);
          e.preventDefault(); // Prevent scrolling while dragging
        });
        
        // Mouse up for range selector
        document.addEventListener('mouseup', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
        
        // Touch end for range selector
        document.addEventListener('touchend', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
        
        // Touch cancel for range selector
        document.addEventListener('touchcancel', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
      }
      
      // Handle chart interaction (mouse or touch)
      function handleChartInteraction(clientX, clientY) {
        if (settings.chartData.length === 0) return;
        
        const rect = mainChart.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        
        const { chartWidth, chartHeight } = getChartDimensions(settings.mainCtx, settings.padding);
        
        if (x >= settings.padding.left && 
            x <= settings.padding.left + chartWidth && 
            y >= settings.padding.top && 
            y <= settings.padding.top + chartHeight) {
          
          const dataIndex = findDataIndexFromX(x, settings.visibleStartIndex, settings.visibleEndIndex, chartWidth, settings.padding.left);
          
          if (dataIndex >= 0 && dataIndex < settings.chartData.length) {
            const dataPoint = settings.chartData[dataIndex];
            
            // Position tooltip
            const tooltipWidth = 200;
            const tooltipHeight = 120;
            let tooltipX = x + 10;
            let tooltipY = y - tooltipHeight - 10;
            
            if (tooltipX + tooltipWidth > rect.width) {
              tooltipX = x - tooltipWidth - 10;
            }
            
            if (tooltipY < 0) {
              tooltipY = y + 10;
            }
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            
            // Update tooltip content
            tooltip.querySelector('.tooltip-date').textContent = formatDate(new Date(dataPoint.timestamp), settings.activeInterval);
            tooltip.querySelector('.tooltip-price').textContent = '$' + formatPrice(dataPoint.price);
            
            const tooltipExtras = tooltip.querySelectorAll('.tooltip-extra');
            tooltipExtras[0].textContent = 'Market Cap: $' + formatLargeNumber(dataPoint.marketCap);
            tooltipExtras[1].textContent = '24h Vol: $' + formatLargeNumber(dataPoint.volume);
            
            // Show tooltip
            tooltip.style.display = 'block';
            
            // Draw vertical line
            drawMainChart(dataIndex);
          }
        } else {
          tooltip.style.display = 'none';
          drawMainChart();
        }
      }
      
      // Handle range handle drag
      function handleRangeHandleDrag(clientX) {
        const rangeRect = rangeSelector.getBoundingClientRect();
        const { chartWidth } = getChartDimensions(settings.rangeCtx, settings.rangePadding);
        const leftBound = rangeRect.left + settings.rangePadding.left;
        const rightBound = leftBound + chartWidth;
        
        let newPos = Math.max(leftBound, Math.min(clientX, rightBound));
        const dataLength = settings.chartData.length;
        
        // Calculate the index based on position
        const percentage = (newPos - leftBound) / chartWidth;
        const newIndex = Math.round(percentage * (dataLength - 1));
        
        if (settings.draggedHandle === 'left') {
          settings.visibleStartIndex = Math.min(newIndex, settings.visibleEndIndex - 1);
        } else {
          settings.visibleEndIndex = Math.max(newIndex, settings.visibleStartIndex + 1);
        }
        
        drawMainChart();
        updateRangeHandles();
      }
      
      // Load chart data for the selected interval
      function loadChartData(interval) {
        loadingOverlay.style.display = 'flex';
        
        // Mock data generation (would be replaced with API call)
        setTimeout(function() {
          settings.chartData = generateMockData(interval);
          
          // Calculate price change percentage
          const firstPrice = settings.chartData[0].price;
          const lastPrice = settings.chartData[settings.chartData.length - 1].price;
          const priceChangeValue = lastPrice - firstPrice;
          const priceChangePercentage = (priceChangeValue / firstPrice) * 100;
          
          // Update price display
          currentPrice.textContent = formatPrice(lastPrice);
          priceChange.textContent = (priceChangePercentage >= 0 ? '+' : '') + priceChangePercentage.toFixed(2) + '%';
          priceChange.className = 'price-change ' + (priceChangePercentage >= 0 ? 'positive' : 'negative');
          
          // Set visible range (default to last 1/3 of data)
          const dataLength = settings.chartData.length;
          settings.visibleStartIndex = Math.max(0, dataLength - Math.floor(dataLength / 3));
          settings.visibleEndIndex = dataLength - 1;
          
          // Draw charts
          drawMainChart();
          drawRangeChart();
          updateRangeHandles();
          
          loadingOverlay.style.display = 'none';
        }, 500);
      }
      
      // Draw the main chart
      function drawMainChart(hoverIndex = -1) {
        const ctx = settings.mainCtx;
        const { chartWidth, chartHeight } = getChartDimensions(ctx, settings.padding);
        const theme = settings.darkTheme;
        
        // Clear canvas
        ctx.fillStyle = theme.backgroundColor;
        ctx.fillRect(0, 0, mainChart.clientWidth, mainChart.clientHeight);
        
        if (settings.chartData.length === 0) return;
        
        // Determine visible data range
        const visibleData = settings.chartData.slice(settings.visibleStartIndex, settings.visibleEndIndex + 1);
        
        // Find min and max values in visible data
        const priceValues = visibleData.map(d => d.price);
        let minPrice = Math.min(...priceValues);
        let maxPrice = Math.max(...priceValues);
        
        // Add some padding to the min/max
        const pricePadding = (maxPrice - minPrice) * 0.1;
        minPrice = Math.max(0, minPrice - pricePadding);
        maxPrice = maxPrice + pricePadding;
        
        // Draw grid and axes
        drawGrid(ctx, chartWidth, chartHeight, settings.padding, theme);
        drawYAxis(ctx, chartHeight, settings.padding, minPrice, maxPrice, theme);
        drawXAxis(ctx, chartWidth, chartHeight, settings.padding, visibleData, theme, settings.activeInterval);
        
        // Draw price line and fill
        drawPriceLine(ctx, chartWidth, chartHeight, settings.padding, visibleData, minPrice, maxPrice, theme);
        
        // Draw reference line (starting price)
        const startPrice = settings.chartData[0].price;
        if (startPrice >= minPrice && startPrice <= maxPrice) {
          const y = chartHeight - ((startPrice - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.padding.top;
          
          ctx.beginPath();
          ctx.strokeStyle = priceValues[priceValues.length - 1] >= startPrice ? '#10B981' : '#EF4444';
          ctx.setLineDash([5, 5]);
          ctx.moveTo(settings.padding.left, y);
          ctx.lineTo(settings.padding.left + chartWidth, y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw hover indicator
        if (hoverIndex >= 0 && hoverIndex < settings.chartData.length) {
          const dataIndex = hoverIndex - settings.visibleStartIndex;
          
          if (dataIndex >= 0 && dataIndex < visibleData.length) {
            const x = (dataIndex / (visibleData.length - 1)) * chartWidth + settings.padding.left;
            
            // Draw vertical line
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.moveTo(x, settings.padding.top);
            ctx.lineTo(x, settings.padding.top + chartHeight);
            ctx.stroke();
            
            // Draw data point
            const price = visibleData[dataIndex].price;
            const y = chartHeight - ((price - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.padding.top;
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = theme.lineColor;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#FFFFFF';
            ctx.stroke();
          }
        }
      }
      
      // Draw the range selector chart
      function drawRangeChart() {
        const ctx = settings.rangeCtx;
        const { chartWidth, chartHeight } = getChartDimensions(ctx, settings.rangePadding);
        const theme = settings.darkTheme;
        
        // Clear canvas
        ctx.fillStyle = theme.backgroundColor;
        ctx.fillRect(0, 0, rangeSelector.clientWidth, rangeSelector.clientHeight);
        
        if (settings.chartData.length === 0) return;
        
        // Find min and max price values
        const priceValues = settings.chartData.map(d => d.price);
        let minPrice = Math.min(...priceValues);
        let maxPrice = Math.max(...priceValues);
        
        // Add some padding to the min/max
        const pricePadding = (maxPrice - minPrice) * 0.1;
        minPrice = Math.max(0, minPrice - pricePadding);
        maxPrice = maxPrice + pricePadding;
        
        // Draw price line and fill
        const points = [];
        for (let i = 0; i < settings.chartData.length; i++) {
          const x = (i / (settings.chartData.length - 1)) * chartWidth + settings.rangePadding.left;
          const y = chartHeight - ((settings.chartData[i].price - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.rangePadding.top;
          points.push({ x, y });
        }
        
        // Draw fill
        ctx.beginPath();
        ctx.moveTo(points[0].x, settings.rangePadding.top + chartHeight);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.lineTo(points[points.length - 1].x, settings.rangePadding.top + chartHeight);
        ctx.closePath();
        ctx.fillStyle = theme.areaColor;
        ctx.fill();
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.strokeStyle = theme.lineColor;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // Draw grid lines and axes background
      function drawGrid(ctx, width, height, padding, theme) {
        const steps = 5;
        
        // Draw background grid
        ctx.strokeStyle = theme.gridColor;
        ctx.lineWidth = 1;
        
        // Horizontal grid lines
        for (let i = 0; i <= steps; i++) {
          const y = padding.top + (height / steps) * i;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + width, y);
          ctx.stroke();
        }
        
        // Vertical grid lines
        const timeSteps = width > 600 ? 6 : 4;
        for (let i = 0; i <= timeSteps; i++) {
          const x = padding.left + (width / timeSteps) * i;
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + height);
          ctx.stroke();
        }
      }
      
      // Draw Y axis (price)
      function drawYAxis(ctx, height, padding, minPrice, maxPrice, theme) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.font = '12px sans-serif';
        ctx.fillStyle = theme.textColor;
        
        const steps = 5;
        for (let i = 0; i <= steps; i++) {
          const y = padding.top + (height / steps) * i;
          const price = maxPrice - ((maxPrice - minPrice) / steps) * i;
          ctx.fillText('$' + formatLargeNumber(price), padding.left - 10, y);
        }
      }
      
      // Draw X axis (time)
      function drawXAxis(ctx, width, height, padding, data, theme, interval) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '12px sans-serif';
        ctx.fillStyle = theme.textColor;
        
        const timeSteps = width > 600 ? 6 : 4;
        for (let i = 0; i <= timeSteps; i++) {
          const x = padding.left + (width / timeSteps) * i;
          const dataIndex = Math.floor((i / timeSteps) * (data.length - 1));
          if (dataIndex >= 0 && dataIndex < data.length) {
            const date = new Date(data[dataIndex].timestamp);
            ctx.fillText(formatDateShort(date, interval), x, padding.top + height + 10);
          }
        }
      }
      
      // Draw price line and fill
      function drawPriceLine(ctx, width, height, padding, data, minPrice, maxPrice, theme) {
        const points = [];
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * width + padding.left;
          const y = height - ((data[i].price - minPrice) / (maxPrice - minPrice)) * height + padding.top;
          points.push({ x, y });
        }
        
        // Draw fill
        ctx.beginPath();
        ctx.moveTo(points[0].x, padding.top + height);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.lineTo(points[points.length - 1].x, padding.top + height);
        ctx.closePath();
        
        const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + height);
        gradient.addColorStop(0, 'rgba(247, 147, 26, 0.4)');
        gradient.addColorStop(1, 'rgba(247, 147, 26, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.strokeStyle = theme.lineColor;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Update range selector handles
      function updateRangeHandles() {
        const rangeRect = rangeSelector.getBoundingClientRect();
        const { chartWidth } = getChartDimensions(settings.rangeCtx, settings.rangePadding);
        const dataLength = settings.chartData.length;
        
        // Calculate positions
        const leftPos = (settings.visibleStartIndex / (dataLength - 1)) * chartWidth + settings.rangePadding.left;
        const rightPos = (settings.visibleEndIndex / (dataLength - 1)) * chartWidth + settings.rangePadding.left;
        
        // Update handle positions
        leftHandle.style.left = (leftPos - 4) + 'px';
        rightHandle.style.left = (rightPos - 4) + 'px';
        
        // Update selected range
        rangeSelected.style.left = leftPos + 'px';
        rangeSelected.style.width = (rightPos - leftPos) + 'px';
      }
      
      // Helper function to get chart dimensions
      function getChartDimensions(ctx, padding) {
        const canvas = ctx.canvas;
        const chartWidth = canvas.clientWidth - padding.left - padding.right;
        const chartHeight = canvas.clientHeight - padding.top - padding.bottom;
        return { chartWidth, chartHeight };
      }
      
      // Find data index from x position
      function findDataIndexFromX(x, startIndex, endIndex, chartWidth, leftPadding) {
        const percentage = (x - leftPadding) / chartWidth;
        const range = endIndex - startIndex;
        return Math.round(startIndex + percentage * range);
      }
      
      // Generate mock data
      function generateMockData(interval) {
        const now = new Date();
        const data = [];
        let days = 7;
        let step = 60 * 60; // 1 hour in seconds
        let currentPrice = 65000 + Math.random() * 5000;
        let startPrice = currentPrice;
        
        switch (interval) {
          case '1D':
            days = 1;
            step = 5 * 60; // 5 minutes
            break;
          case '7D':
            days = 7;
            step = 60 * 60; // 1 hour
            break;
          case '1M':
            days = 30;
            step = 4 * 60 * 60; // 4 hours
            break;
          case '1Y':
            days = 365;
            step = 24 * 60 * 60; // 1 day
            break;
          case 'ALL':
            days = 365 * 5; // 5 years
            step = 7 * 24 * 60 * 60; // 1 week
            currentPrice = 5000;
            startPrice = currentPrice;
            break;
        }
        
        const startTime = now.getTime() - (days * 24 * 60 * 60 * 1000);
        
        for (let i = 0; i <= days * 24 * 60 * 60; i += step) {
          const timestamp = startTime + (i * 1000);
          
          // Add some price variation
          const multiplier = (Math.random() - 0.5) * 0.01;
          if (interval === 'ALL') {
            currentPrice *= (1 + (Math.random() - 0.3) * 0.03); // Larger upward trend for ALL
          } else {
            currentPrice *= (1 + multiplier);
          }
          
          const marketCap = currentPrice * 19000000; // Approx BTC supply
          const volume = marketCap * (0.02 + Math.random() * 0.05); // Random volume between 2-7% of market cap
          
          data.push({
            timestamp,
            price: currentPrice,
            marketCap,
            volume
          });
        }
        
        return data;
      }
      
      // Format helpers
      function formatDate(date, interval) {
        if (interval === '1D') {
          return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
        } else if (interval === '7D' || interval === '1M') {
          return date.toLocaleDateString(undefined, { 
            month: 'short', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          });
        } else {
          return date.toLocaleDateString(undefined, { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
        }
      }
      
      function formatDateShort(date, interval) {
        if (interval === '1D') {
          return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
        } else if (interval === '7D') {
          return date.toLocaleDateString(undefined, { weekday: 'short' });
        } else if (interval === '1M') {
          return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        } else {
          return date.toLocaleDateString(undefined, { month: 'short', year: '2-digit' });
        }
      }
      
      function formatPrice(price) {
        return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }
      
      function formatLargeNumber(num) {
        if (num >= 1e12) {
          return (num / 1e12).toFixed(2) + 'T';
        } else if (num >= 1e9) {
          return (num / 1e9).toFixed(2) + 'B';
        } else if (num >= 1e6) {
          return (num / 1e6).toFixed(2) + 'M';
        } else {
          return num.toLocaleString();
        }
      }
      
      // Throttle function for performance
      function throttle(callback, delay) {
        let lastCall = 0;
        return function(...args) {
          const now = new Date().getTime();
          if (now - lastCall >= delay) {
            lastCall = now;
            callback.apply(this, args);
          }
        };
      }
      
      // Initialize chart on page load
      window.addEventListener('load', initChart);
      
    })();
  </script>
</body>
</html>
