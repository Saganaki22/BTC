<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Price Chart | Real-time BTC/USD Tracking</title>

  <!-- Meta Description -->
  <meta name="description" content="Track Bitcoin price movements in real-time with our interactive chart. View BTC/USD price history, market cap, and trading volume with customizable time intervals.">

  <!-- Open Graph Meta Tags (for social sharing) -->
  <meta property="og:title" content="Bitcoin Price Chart | Real-time BTC/USD Tracking">
  <meta property="og:description" content="Track Bitcoin price movements in real-time with our interactive chart. View BTC/USD price history, market cap, and trading volume with customizable time intervals.">
  <meta property="og:image" content="https://i.ibb.co/Z64vLH8C/btceee.jpg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://drbaph.is-a.dev/BTC/">

  <!-- Twitter Card (for better previews on Twitter) -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Bitcoin Price Chart | Real-time BTC/USD Tracking">
  <meta name="twitter:description" content="Track Bitcoin price movements in real-time with our interactive chart. View BTC/USD price history, market cap, and trading volume with customizable time intervals.">
  <meta name="twitter:image" content="https://i.ibb.co/Z64vLH8C/btceee.jpg">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }
    
    body {
      background-color: #111827;
      color: #F3F4F6;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
      position: relative;
    }
    
    .github-link {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: 32px;
      height: 32px;
      color: #F3F4F6;
      transition: color 0.2s;
      z-index: 100;
    }
    
    .github-link:hover {
      color: #F7931A;
    }
    
    .search-container {
      margin: 2rem auto 1rem auto;
      max-width: 600px;
      width: 100%;
    }
    
    .search-form {
      display: flex;
      width: 100%;
      position: relative;
    }
    
    .search-input {
      flex: 1;
      padding: 0.75rem 1rem;
      border-radius: 2rem;
      border: 1px solid #374151;
      background-color: #1F2937;
      color: #F3F4F6;
      font-size: 1rem;
      outline: none;
      transition: all 0.2s;
      padding-right: 3rem;
    }
    
    .search-input:focus {
      border-color: #F7931A;
      box-shadow: 0 0 0 2px rgba(247, 147, 26, 0.25);
    }
    
    .search-input::placeholder {
      color: #6B7280;
    }
    
    .search-button {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #6B7280;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      transition: all 0.2s;
    }
    
    .search-button:hover {
      color: #F7931A;
      background-color: rgba(247, 147, 26, 0.1);
    }
    
    .chart-container {
      border-radius: 0.5rem;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      background-color: #1F2937;
      margin: 1rem auto 2rem auto;
      width: 100%;
    }
    
    .chart-header {
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }
    
    .header-content {
      display: flex;
      flex-direction: column;
    }
    
    .chart-title {
      display: flex;
      align-items: center;
      font-size: 1.25rem;
      font-weight: bold;
      color: white;
      margin: 0 0 1rem 0;
    }
    
    .chart-title svg {
      margin-right: 0.5rem;
    }
    
    .time-intervals {
      display: flex;
      align-items: center;
      background-color: #374151;
      border-radius: 0.5rem;
      padding: 0.25rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .interval-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background: none;
      border: none;
      cursor: pointer;
      transition: all 0.15s ease;
      white-space: nowrap;
    }
    
    .interval-btn.active {
      background-color: #F7931A;
      color: white;
      font-weight: 500;
    }
    
    .interval-btn:not(.active) {
      color: #9CA3AF;
    }
    
    .interval-btn:not(.active):hover {
      color: white;
    }
    
    .chart-body {
      position: relative;
      padding: 1rem;
    }
    
    .price-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    
    .price-label {
      color: #9CA3AF;
      font-size: 0.875rem;
    }
    
    .price-value {
      display: flex;
      align-items: center;
      font-size: 1.25rem;
      font-weight: bold;
      color: white;
    }
    
    .price-change {
      margin-left: 0.5rem;
      font-size: 0.875rem;
      font-weight: normal;
    }
    
    .price-change.positive {
      color: #10B981;
    }
    
    .price-change.negative {
      color: #EF4444;
    }
    
    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 400px;
      margin-bottom: 1rem;
    }
    
    #mainChart {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    #rangeSelector {
      width: 100%;
      height: 60px;
      cursor: grab;
    }
    
    .tooltip {
      position: absolute;
      background-color: #374151;
      border: 1px solid #4B5563;
      border-radius: 0.375rem;
      padding: 0.75rem;
      pointer-events: none;
      display: none;
      z-index: 10;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    
    .tooltip-date {
      font-size: 0.75rem;
      color: #D1D4DC;
      margin: 0 0 0.5rem 0;
    }
    
    .tooltip-price {
      font-size: 1.125rem;
      font-weight: bold;
      color: white;
      margin: 0 0 0.5rem 0;
    }
    
    .tooltip-extra {
      font-size: 0.75rem;
      color: #9CA3AF;
      margin: 0;
    }
    
    .range-handles {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      pointer-events: none;
    }
    
    .range-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 60px;
      background-color: #F7931A;
      border-radius: 4px;
      cursor: col-resize;
      pointer-events: all;
      touch-action: none;
    }
    
    .range-selected {
      position: absolute;
      top: 0;
      height: 60px;
      background-color: rgba(247, 147, 26, 0.2);
      pointer-events: none;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(31, 41, 55, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #F7931A;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .chart-footer {
      margin-top: 1rem;
      color: #6B7280;
      font-size: 0.75rem;
    }
    
    .error-message {
      background-color: #7F1D1D;
      color: #FEE2E2;
      padding: 1rem;
      border-radius: 0.5rem;
      margin: 1rem 0;
      text-align: center;
    }

    .cache-info {
      background-color: #064E3B;
      color: #A7F3D0;
      padding: 0.5rem;
      border-radius: 0.375rem;
      margin: 0.5rem 0;
      text-align: center;
      font-size: 0.75rem;
    }

    .api-status {
      background-color: #1E3A8A;
      color: #BFDBFE;
      padding: 0.5rem;
      border-radius: 0.375rem;
      margin: 0.5rem 0;
      text-align: center;
      font-size: 0.75rem;
    }

    .success-info {
      background-color: #064E3B;
      color: #A7F3D0;
      padding: 0.5rem;
      border-radius: 0.375rem;
      margin: 0.5rem 0;
      text-align: center;
      font-size: 0.75rem;
    }
    
    .tip-jar {
      margin: 2rem auto;
      max-width: 600px;
      text-align: center;
      width: 100%;
    }
    
    .tip-jar-title {
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: #F7931A;
    }
    
    .tip-address-container {
      background-color: #1F2937;
      border-radius: 0.5rem;
      padding: 1rem;
      border: 1px solid #374151;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .tip-address {
      font-family: monospace;
      font-size: 1rem;
      color: #D1D4DC;
      overflow-wrap: break-word;
      text-align: center;
      margin-right: 10px;
    }
    
    .copy-button {
      background-color: #374151;
      border: none;
      color: #D1D4DC;
      width: 36px;
      height: 36px;
      border-radius: 0.375rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    
    .copy-button:hover {
      background-color: #4B5563;
      color: white;
    }
    
    .copy-button:active {
      transform: scale(0.95);
    }
    
    .copy-success {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #059669;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .copy-success.show {
      opacity: 1;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Responsive adjustments */
    @media (min-width: 640px) {
      .header-content {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
      
      .chart-title {
        margin-bottom: 0;
      }
    }
    
    @media (max-width: 639px) {
      .chart-wrapper {
        height: 300px;
      }
      
      .time-intervals {
        justify-content: space-between;
      }
      
      .interval-btn {
        padding: 0.5rem;
        font-size: 0.75rem;
      }
      
      .price-info {
        margin-top: 0.5rem;
      }
      
      .price-value {
        font-size: 1.125rem;
      }
      
      .tip-address-container {
        flex-direction: column;
      }
      
      .tip-address {
        margin-right: 0;
        margin-bottom: 10px;
        font-size: 0.875rem;
      }
    }
    
    @media (max-width: 480px) {
      .chart-wrapper {
        height: 250px;
      }
      
      .chart-title {
        font-size: 1rem;
      }
      
      .interval-btn {
        padding: 0.25rem 0.5rem;
      }
      
      .chart-header, .chart-body {
        padding: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <a href="https://github.com/Saganaki22/BTC" class="github-link" title="View on GitHub">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
    </svg>
  </a>
  
  <div class="container">
    <div class="search-container">
      <form id="searchForm" class="search-form">
        <input 
          type="text" 
          id="searchInput" 
          class="search-input" 
          placeholder="Search for wallet address or transaction ID..." 
          autocomplete="off"
          spellcheck="false"
        >
        <button type="submit" class="search-button" title="Search mempool.space">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
        </button>
      </form>
    </div>
    
    <div class="chart-container">
      <div class="chart-header">
        <div class="header-content">
          <h2 class="chart-title">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 4091.27 4091.73">
              <g>
                <path fill="#F7931A" fill-rule="nonzero" d="M4030.06 2540.77c-273.24,1096.01 -1383.32,1763.02 -2479.46,1489.71 -1095.68,-273.24 -1762.69,-1383.39 -1489.33,-2479.31 273.12,-1096.13 1383.2,-1763.19 2479,-1489.95 1096.06,273.24 1763.03,1383.51 1489.76,2479.57l0.02 -0.02z"></path>
                <path fill="white" fill-rule="nonzero" d="M2947.77 1754.38c40.72,-272.26 -166.56,-418.61 -450,-516.24l91.95 -368.8 -224.5 -55.94 -89.51 359.09c-59.02,-14.72 -119.63,-28.59 -179.87,-42.34l90.16 -361.46 -224.36 -55.94 -92 368.68c-48.84,-11.12 -96.81,-22.11 -143.35,-33.69l0.26 -1.16 -309.59 -77.31 -59.72 239.78c0,0 166.56,38.18 163.05,40.53 90.91,22.69 107.35,82.87 104.62,130.57l-104.74 420.15c6.26,1.59 14.38,3.89 23.34,7.49 -7.49,-1.86 -15.46,-3.89 -23.73,-5.87l-146.81 588.57c-11.11,27.62 -39.31,69.07 -102.87,53.33 2.25,3.26 -163.17,-40.72 -163.17,-40.72l-111.46 256.98 292.15 72.83c54.35,13.63 107.61,27.89 160.06,41.3l-92.9 373.03 224.24 55.94 92 -369.07c61.26,16.63 120.71,31.97 178.91,46.43l-91.69 367.33 224.51 55.94 92.89 -372.33c382.82,72.45 670.67,43.24 791.83,-303.02 97.63,-278.78 -4.86,-439.58 -206.26,-544.44 146.69,-33.83 257.18,-130.31 286.64,-329.61l-0.07 -0.05zm-512.93 719.26c-69.38,278.78 -538.76,128.08 -690.94,90.29l123.28 -494.2c152.17,37.99 640.17,113.17 567.67,403.91zm69.43 -723.3c-63.29,253.58 -453.96,124.75 -580.69,93.16l111.77 -448.21c126.73,31.59 534.85,90.55 468.94,355.05l-0.02 0z"></path>
              </g>
            </svg>
            Bitcoin Price Chart
          </h2>
          <div class="time-intervals">
            <button class="interval-btn" data-interval="1D">1D</button>
            <button class="interval-btn active" data-interval="7D">7D</button>
            <button class="interval-btn" data-interval="1M">1M</button>
            <button class="interval-btn" data-interval="1Y">1Y</button>
            <button class="interval-btn" data-interval="ALL">ALL</button>
          </div>
        </div>
      </div>
      
      <div class="chart-body">
        <div id="loadingOverlay" class="loading-overlay">
          <div class="spinner"></div>
        </div>
        
        <div id="errorMessage" class="error-message" style="display: none;">
          <p>All APIs temporarily unavailable. Showing realistic Bitcoin price patterns.</p>
        </div>

        <div id="cacheInfo" class="cache-info" style="display: none;">
          <p>📊 Using cached data to reduce API calls • Next update in: <span id="nextUpdate"></span></p>
        </div>

        <div id="apiStatus" class="api-status" style="display: none;">
          <p>🔄 Fetching real Bitcoin data...</p>
        </div>

        <div id="successInfo" class="success-info" style="display: none;">
          <p>✅ <span id="dataSource">Real Bitcoin data loaded</span></p>
        </div>
        
        <div class="price-info">
          <div class="price-label">Price (USD)</div>
          <div class="price-value">
            $<span id="currentPrice">0.00</span>
            <span id="priceChange" class="price-change">+0.00%</span>
          </div>
        </div>
        
        <div class="chart-wrapper">
          <canvas id="mainChart"></canvas>
          <div id="tooltip" class="tooltip">
            <p class="tooltip-date"></p>
            <p class="tooltip-price"></p>
            <p class="tooltip-extra"></p>
            <p class="tooltip-extra"></p>
          </div>
        </div>
        
        <div class="chart-wrapper" style="height: 60px;">
          <canvas id="rangeSelector"></canvas>
          <div class="range-handles">
            <div class="range-selected"></div>
            <div class="range-handle" id="leftHandle"></div>
            <div class="range-handle" id="rightHandle"></div>
          </div>
        </div>
        
        <div class="chart-footer">
          Real Bitcoin data with intelligent caching • Last updated: <span id="lastUpdated"></span>
        </div>
      </div>
    </div>
    
    <div class="tip-jar">
      <h3 class="tip-jar-title">Tip Jar</h3>
      <div class="tip-address-container">
        <div class="tip-address">bc1qlp5urduycv8kaynym0z6cvgqwk7frxr8vk489a</div>
        <button class="copy-button" id="copyButton" title="Copy address">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
        <div class="copy-success" id="copySuccess">Copied!</div>
      </div>
    </div>
  </div>

  <script>
    // Bitcoin Chart Application with Real Historical Data
    (function() {
      // DOM Elements
      const mainChart = document.getElementById('mainChart');
      const rangeSelector = document.getElementById('rangeSelector');
      const tooltip = document.getElementById('tooltip');
      const currentPrice = document.getElementById('currentPrice');
      const priceChange = document.getElementById('priceChange');
      const lastUpdated = document.getElementById('lastUpdated');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const errorMessage = document.getElementById('errorMessage');
      const cacheInfo = document.getElementById('cacheInfo');
      const apiStatus = document.getElementById('apiStatus');
      const successInfo = document.getElementById('successInfo');
      const dataSource = document.getElementById('dataSource');
      const nextUpdate = document.getElementById('nextUpdate');
      const leftHandle = document.getElementById('leftHandle');
      const rightHandle = document.getElementById('rightHandle');
      const rangeSelected = document.querySelector('.range-selected');
      const intervalButtons = document.querySelectorAll('.interval-btn');
      const copyButton = document.getElementById('copyButton');
      const copySuccess = document.getElementById('copySuccess');
      const searchForm = document.getElementById('searchForm');
      const searchInput = document.getElementById('searchInput');
      
      // Set up clipboard functionality
      copyButton.addEventListener('click', function() {
        const address = 'bc1qlp5urduycv8kaynym0z6cvgqwk7frxr8vk489a';
        navigator.clipboard.writeText(address).then(function() {
          copySuccess.classList.add('show');
          setTimeout(function() {
            copySuccess.classList.remove('show');
          }, 2000);
        });
      });
      
      // Set up search functionality
      searchForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const query = searchInput.value.trim();
        
        if (!query) return;
        
        let url;
        
        // Basic validation for Bitcoin address format
        if (query.startsWith('bc1') || query.startsWith('1') || query.startsWith('3')) {
          url = `https://mempool.space/address/${query}`;
        } else {
          // Treat as transaction ID by default
          url = `https://mempool.space/tx/${query}`;
        }
        
        window.open(url, '_blank');
      });
      
      // Chart settings
      const settings = {
        mainCtx: mainChart.getContext('2d'),
        rangeCtx: rangeSelector.getContext('2d'),
        darkTheme: {
          backgroundColor: '#1F2937',
          gridColor: '#374151',
          textColor: '#D1D4DC',
          lineColor: '#F7931A',
          areaColor: 'rgba(247, 147, 26, 0.2)',
          referenceLineColor: '#10B981'
        },
        padding: { top: 20, right: 60, bottom: 30, left: 70 },
        rangePadding: { top: 5, right: 60, bottom: 5, left: 70 },
        activeInterval: '7D',
        chartData: [],
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        isDragging: false,
        draggedHandle: null,
        mouseMoveThrottleId: null,
        touchStartX: 0,
        lastApiCall: {},
        nextApiCall: {},
        cacheCountdown: null,
        dataSource: 'simulation'
      };
      
      // Multiple API sources for both current price and historical data
      const API_SOURCES = {
        current: [
          {
            name: 'Binance',
            url: 'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',
            parsePrice: (data) => parseFloat(data.price)
          },
          {
            name: 'CoinCap',
            url: 'https://api.coincap.io/v2/assets/bitcoin',
            parsePrice: (data) => parseFloat(data.data.priceUsd)
          },
          {
            name: 'CryptoCompare',
            url: 'https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD',
            parsePrice: (data) => data.USD
          }
        ],
        historical: [
          {
            name: 'Binance',
            getUrl: (interval) => {
              const intervals = {
                '1D': { klineInterval: '5m', limit: 288 }, // 5min * 288 = 24h
                '7D': { klineInterval: '1h', limit: 168 }, // 1h * 168 = 7d
                '1M': { klineInterval: '4h', limit: 180 }, // 4h * 180 = 30d
                '1Y': { klineInterval: '1d', limit: 365 }, // 1d * 365 = 1y
                'ALL': { klineInterval: '1w', limit: 260 }  // 1w * 260 = 5y
              };
              const config = intervals[interval];
              return `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${config.klineInterval}&limit=${config.limit}`;
            },
            parseData: (data) => {
              return data.map(candle => ({
                timestamp: candle[0],
                price: parseFloat(candle[4]), // close price
                volume: parseFloat(candle[5])
              }));
            }
          },
          {
            name: 'CoinCap',
            getUrl: (interval) => {
              const intervals = {
                '1D': 'm5',   // 5 minute
                '7D': 'h1',   // 1 hour  
                '1M': 'h6',   // 6 hour
                '1Y': 'd1',   // 1 day
                'ALL': 'd1'   // 1 day
              };
              const intervalParam = intervals[interval];
              const end = Date.now();
              const starts = {
                '1D': end - (24 * 60 * 60 * 1000),
                '7D': end - (7 * 24 * 60 * 60 * 1000), 
                '1M': end - (30 * 24 * 60 * 60 * 1000),
                '1Y': end - (365 * 24 * 60 * 60 * 1000),
                'ALL': end - (5 * 365 * 24 * 60 * 60 * 1000)
              };
              return `https://api.coincap.io/v2/assets/bitcoin/history?interval=${intervalParam}&start=${starts[interval]}&end=${end}`;
            },
            parseData: (data) => {
              return data.data.map(point => ({
                timestamp: point.time,
                price: parseFloat(point.priceUsd),
                volume: 0 // CoinCap doesn't provide volume in history
              }));
            }
          }
        ]
      };
      
      // Cache configuration - shorter times for more frequent updates
      const CACHE_CONFIG = {
        '1D': 2 * 60 * 1000,      // 2 minutes
        '7D': 5 * 60 * 1000,      // 5 minutes  
        '1M': 15 * 60 * 1000,     // 15 minutes
        '1Y': 30 * 60 * 1000,     // 30 minutes
        'ALL': 60 * 60 * 1000     // 1 hour
      };
      
      // Enhanced cache management
      const cache = {
        get: function(key) {
          try {
            const item = localStorage.getItem('btc_' + key);
            if (!item) return null;
            
            const data = JSON.parse(item);
            if (Date.now() > data.expiry) {
              localStorage.removeItem('btc_' + key);
              return null;
            }
            return data.value;
          } catch (e) {
            return null;
          }
        },
        
        set: function(key, value, duration) {
          try {
            const item = {
              value: value,
              expiry: Date.now() + duration,
              created: Date.now()
            };
            localStorage.setItem('btc_' + key, JSON.stringify(item));
            return true;
          } catch (e) {
            console.warn('Cache storage failed:', e);
            return false;
          }
        },
        
        getExpiry: function(key) {
          try {
            const item = localStorage.getItem('btc_' + key);
            if (!item) return null;
            
            const data = JSON.parse(item);
            return data.expiry;
          } catch (e) {
            return null;
          }
        }
      };
      
      // Initialize chart
      function initChart() {
        updateCanvasSize();
        setupEventListeners();
        loadChartData('7D');
      }
      
      // Update canvas size based on container
      function updateCanvasSize() {
        const dpr = window.devicePixelRatio || 1;
        
        // Main chart
        const mainRect = mainChart.getBoundingClientRect();
        mainChart.width = mainRect.width * dpr;
        mainChart.height = mainRect.height * dpr;
        settings.mainCtx.scale(dpr, dpr);
        
        // Range selector
        const rangeRect = rangeSelector.getBoundingClientRect();
        rangeSelector.width = rangeRect.width * dpr;
        rangeSelector.height = rangeRect.height * dpr;
        settings.rangeCtx.scale(dpr, dpr);
      }
      
      // Set up event listeners
      function setupEventListeners() {
        // Resize listener
        window.addEventListener('resize', function() {
          updateCanvasSize();
          if (settings.chartData.length > 0) {
            drawMainChart();
            drawRangeChart();
            updateRangeHandles();
          }
        });
        
        // Interval buttons
        intervalButtons.forEach(button => {
          button.addEventListener('click', function() {
            intervalButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            settings.activeInterval = this.dataset.interval;
            loadChartData(settings.activeInterval);
          });
        });
        
        // Mouse interaction with main chart
        mainChart.addEventListener('mousemove', throttle(function(e) {
          handleChartInteraction(e.clientX, e.clientY);
        }, 30));
        
        // Touch interaction with main chart
        mainChart.addEventListener('touchmove', throttle(function(e) {
          if (e.touches && e.touches[0]) {
            handleChartInteraction(e.touches[0].clientX, e.touches[0].clientY);
          }
        }, 30));
        
        mainChart.addEventListener('mouseleave', function() {
          tooltip.style.display = 'none';
          drawMainChart();
        });
        
        mainChart.addEventListener('touchend', function() {
          tooltip.style.display = 'none';
          drawMainChart();
        });
        
        // Range selector mouse events
        leftHandle.addEventListener('mousedown', function(e) {
          e.preventDefault();
          settings.isDragging = true;
          settings.draggedHandle = 'left';
        });
        
        rightHandle.addEventListener('mousedown', function(e) {
          e.preventDefault();
          settings.isDragging = true;
          settings.draggedHandle = 'right';
        });
        
        // Range selector touch events
        leftHandle.addEventListener('touchstart', function(e) {
          if (e.touches && e.touches[0]) {
            e.preventDefault();
            settings.isDragging = true;
            settings.draggedHandle = 'left';
            settings.touchStartX = e.touches[0].clientX;
          }
        });
        
        rightHandle.addEventListener('touchstart', function(e) {
          if (e.touches && e.touches[0]) {
            e.preventDefault();
            settings.isDragging = true;
            settings.draggedHandle = 'right';
            settings.touchStartX = e.touches[0].clientX;
          }
        });
        
        // Mouse move for range selector
        document.addEventListener('mousemove', function(e) {
          if (!settings.isDragging || !settings.draggedHandle) return;
          handleRangeHandleDrag(e.clientX);
        });
        
        // Touch move for range selector
        document.addEventListener('touchmove', function(e) {
          if (!settings.isDragging || !settings.draggedHandle || !e.touches || !e.touches[0]) return;
          handleRangeHandleDrag(e.touches[0].clientX);
          e.preventDefault();
        });
        
        // Mouse up for range selector
        document.addEventListener('mouseup', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
        
        // Touch end for range selector
        document.addEventListener('touchend', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
        
        // Touch cancel for range selector
        document.addEventListener('touchcancel', function() {
          settings.isDragging = false;
          settings.draggedHandle = null;
        });
      }
      
      // Load chart data with real historical data
      async function loadChartData(interval) {
        const cacheKey = `chart_${interval}`;
        
        // Check cache first
        const cachedData = cache.get(cacheKey);
        if (cachedData) {
          console.log(`Using cached data for ${interval}`);
          settings.chartData = cachedData.chartData;
          settings.dataSource = cachedData.source || 'cache';
          updateChart(cachedData);
          showCacheInfo(interval);
          return;
        }
        
        showLoading(true);
        hideAllMessages();
        showApiStatus('Fetching real Bitcoin data...');
        
        let historicalData = null;
        let currentPriceData = null;
        let usedSource = null;
        
        // Try to get real historical data
        for (const source of API_SOURCES.historical) {
          try {
            console.log(`Trying ${source.name} historical API for ${interval}...`);
            const url = source.getUrl(interval);
            
            const response = await fetch(url);
            if (response.ok) {
              const rawData = await response.json();
              historicalData = source.parseData(rawData);
              
              if (historicalData && historicalData.length > 0) {
                usedSource = source.name;
                console.log(`Got ${historicalData.length} historical points from ${source.name}`);
                break;
              }
            }
          } catch (error) {
            console.warn(`${source.name} historical API failed:`, error.message);
          }
        }
        
        // If we got historical data, try to get current price to adjust the end
        if (historicalData) {
          for (const source of API_SOURCES.current) {
            try {
              const response = await fetch(source.url);
              if (response.ok) {
                const rawData = await response.json();
                const price = source.parsePrice(rawData);
                
                if (price && price > 0) {
                  currentPriceData = { price, timestamp: Date.now() };
                  console.log(`Got current price from ${source.name}: $${price}`);
                  // Update the last data point with current price
                  if (historicalData.length > 0) {
                    historicalData[historicalData.length - 1].price = price;
                    historicalData[historicalData.length - 1].timestamp = Date.now();
                  }
                  break;
                }
              }
            } catch (error) {
              console.warn(`${source.name} current price API failed:`, error.message);
            }
          }
        }
        
        let chartData;
        let sourceDescription;
        
        if (historicalData && historicalData.length > 0) {
          // Process real historical data
          chartData = processHistoricalData(historicalData);
          sourceDescription = `Real data from ${usedSource}`;
          settings.dataSource = `real_${usedSource}`;
          
          showSuccessInfo(sourceDescription);
          console.log(`Using real historical data from ${usedSource}`);
        } else {
          // Fallback to realistic simulation
          console.log('All historical APIs failed, generating realistic simulation');
          chartData = generateRealisticHistoricalData(interval, currentPriceData?.price);
          sourceDescription = 'Realistic Bitcoin simulation';
          settings.dataSource = 'simulation';
          showError();
        }
        
        settings.chartData = chartData;
        
        // Prepare data for caching
        const dataToCache = {
          chartData: settings.chartData,
          timestamp: Date.now(),
          source: settings.dataSource
        };
        
        // Cache the data
        cache.set(cacheKey, dataToCache, CACHE_CONFIG[interval]);
        
        // Update chart
        updateChart(dataToCache);
        
        showLoading(false);
        hideApiStatus();
      }
      
      // Process real historical data from APIs
      function processHistoricalData(rawData) {
        return rawData.map(point => {
          const price = point.price;
          const timestamp = point.timestamp;
          const volume = point.volume || (price * 19700000 * 0.05); // Estimate volume if not provided
          const marketCap = price * 19700000; // Approximate BTC supply
          
          return {
            timestamp,
            price,
            marketCap,
            volume
          };
        }).filter(point => point.price > 0); // Remove any invalid data points
      }
      
      // Generate realistic historical data based on actual Bitcoin patterns
      function generateRealisticHistoricalData(interval, currentPrice = null) {
        // Real Bitcoin historical reference points for authenticity
        const REAL_BTC_MILESTONES = {
          '2024-12': 95000,  // Recent high
          '2024-01': 42000,  // Start of 2024
          '2023-01': 16500,  // Bear market low
          '2021-11': 69000,  // All-time high
          '2020-03': 3800,   // COVID crash
          '2017-12': 19700,  // 2017 peak
          '2015-01': 200,    // Bear market bottom
          '2013-12': 1100,   // Early peak
          '2010-01': 0.1     // Very early days
        };
        
        const basePrice = currentPrice || 67000; // Current estimated price range
        const now = Date.now();
        const data = [];
        
        let days, step, startPrice;
        
        switch (interval) {
          case '1D':
            days = 1;
            step = 5 * 60 * 1000; // 5 minutes
            startPrice = basePrice * (0.98 + Math.random() * 0.04); // ±2% from current
            break;
          case '7D':
            days = 7;
            step = 60 * 60 * 1000; // 1 hour
            startPrice = basePrice * (0.92 + Math.random() * 0.16); // ±8% from current
            break;
          case '1M':
            days = 30;
            step = 4 * 60 * 60 * 1000; // 4 hours
            startPrice = basePrice * (0.8 + Math.random() * 0.4); // ±20% from current
            break;
          case '1Y':
            days = 365;
            step = 24 * 60 * 60 * 1000; // 1 day 
            startPrice = REAL_BTC_MILESTONES['2024-01'] * (0.9 + Math.random() * 0.2);
            break;
          case 'ALL':
            days = 365 * 5; // 5 years
            step = 7 * 24 * 60 * 60 * 1000; // 1 week
            startPrice = REAL_BTC_MILESTONES['2020-03'] * (0.8 + Math.random() * 0.4);
            break;
        }
        
        const startTime = now - (days * 24 * 60 * 60 * 1000);
        let price = startPrice;
        
        for (let time = startTime; time <= now; time += step) {
          const timeProgress = (time - startTime) / (now - startTime);
          
          // Apply realistic volatility patterns based on Bitcoin's actual behavior
          let volatility;
          let trendFactor = 0;
          
          if (interval === '1D') {
            volatility = 0.005 + Math.random() * 0.01; // 0.5-1.5% intraday
          } else if (interval === '7D') {
            volatility = 0.02 + Math.random() * 0.03; // 2-5% weekly swings
          } else if (interval === '1M') {
            volatility = 0.04 + Math.random() * 0.06; // 4-10% monthly
            // Add some monthly trend
            trendFactor = Math.sin(timeProgress * Math.PI * 6) * 0.001;
          } else if (interval === '1Y') {
            volatility = 0.06 + Math.random() * 0.08; // 6-14% yearly
            // Simulate market cycles
            const yearCycle = Math.sin(timeProgress * Math.PI * 2) * 0.3;
            trendFactor = yearCycle * 0.002;
          } else if (interval === 'ALL') {
            volatility = 0.08 + Math.random() * 0.12; // 8-20% for 5-year periods
            // Major Bitcoin cycles (roughly 4-year halvings)
            const majorCycle = Math.sin(timeProgress * Math.PI * 2.5);
            const secondaryCycle = Math.sin(timeProgress * Math.PI * 8) * 0.3;
            trendFactor = (majorCycle + secondaryCycle) * 0.003;
            // Long-term growth trend
            trendFactor += 0.0015; // Upward bias over 5 years
          }
          
          // Random walk with momentum (more realistic than pure random)
          const randomChange = (Math.random() - 0.5) * volatility;
          const momentum = 0.15; // 15% momentum from previous changes
          
          // Apply price change
          const totalChange = trendFactor + randomChange;
          price *= (1 + totalChange);
          
          // Keep price within realistic bounds for Bitcoin
          if (interval === 'ALL') {
            price = Math.max(100, Math.min(price, 150000)); // 5-year range
          } else if (interval === '1Y') {
            price = Math.max(15000, Math.min(price, 100000)); // 1-year range
          } else {
            price = Math.max(30000, Math.min(price, 85000)); // Shorter-term range
          }
          
          // Calculate realistic market metrics
          const marketCap = price * 19700000; // Current BTC supply
          const volume = marketCap * (0.01 + Math.random() * 0.09); // 1-10% daily volume
          
          data.push({
            timestamp: time,
            price: price,
            marketCap: marketCap,
            volume: volume
          });
        }
        
        // Ensure the last price matches current if provided
        if (currentPrice && data.length > 0) {
          data[data.length - 1].price = currentPrice;
          data[data.length - 1].marketCap = currentPrice * 19700000;
          data[data.length - 1].timestamp = now;
        }
        
        return data;
      }
      
      // Update chart with data
      function updateChart(data) {
        // Calculate price change percentage
        const firstPrice = settings.chartData[0].price;
        const lastPrice = settings.chartData[settings.chartData.length - 1].price;
        const priceChangeValue = lastPrice - firstPrice;
        const priceChangePercentage = (priceChangeValue / firstPrice) * 100;
        
        // Update price display
        currentPrice.textContent = formatPrice(lastPrice);
        priceChange.textContent = (priceChangePercentage >= 0 ? '+' : '') + priceChangePercentage.toFixed(2) + '%';
        priceChange.className = 'price-change ' + (priceChangePercentage >= 0 ? 'positive' : 'negative');
        
        // Set visible range
        const dataLength = settings.chartData.length;
        if (settings.activeInterval === '1D' || settings.activeInterval === '7D') {
          settings.visibleStartIndex = 0;
          settings.visibleEndIndex = dataLength - 1;
        } else {
          settings.visibleStartIndex = Math.max(0, dataLength - Math.floor(dataLength / 2));
          settings.visibleEndIndex = dataLength - 1;
        }
        
        // Draw charts
        drawMainChart();
        drawRangeChart();
        updateRangeHandles();
        
        // Update last updated time
        lastUpdated.textContent = new Date(data.timestamp || Date.now()).toLocaleString();
      }
      
      // Show/hide UI messages
      function showLoading(show) {
        loadingOverlay.style.display = show ? 'flex' : 'none';
      }
      
      function showError() {
        errorMessage.style.display = 'block';
      }
      
      function hideError() {
        errorMessage.style.display = 'none';
      }
      
      function showCacheInfo(interval) {
        const expiry = cache.getExpiry(`chart_${interval}`);
        if (expiry) {
          cacheInfo.style.display = 'block';
          startCacheCountdown(expiry);
        }
      }
      
      function hideCacheInfo() {
        cacheInfo.style.display = 'none';
        if (settings.cacheCountdown) {
          clearInterval(settings.cacheCountdown);
          settings.cacheCountdown = null;
        }
      }
      
      function showApiStatus(message) {
        apiStatus.style.display = 'block';
        apiStatus.querySelector('p').textContent = '🔄 ' + message;
      }
      
      function hideApiStatus() {
        apiStatus.style.display = 'none';
      }
      
      function showSuccessInfo(message) {
        successInfo.style.display = 'block';
        dataSource.textContent = message;
        setTimeout(() => {
          successInfo.style.display = 'none';
        }, 3000);
      }
      
      function hideAllMessages() {
        hideError();
        hideCacheInfo();
        hideApiStatus();
        successInfo.style.display = 'none';
      }
      
      // Start cache countdown
      function startCacheCountdown(expiry) {
        if (settings.cacheCountdown) {
          clearInterval(settings.cacheCountdown);
        }
        
        settings.cacheCountdown = setInterval(() => {
          const remaining = expiry - Date.now();
          if (remaining <= 0) {
            hideCacheInfo();
            return;
          }
          
          const minutes = Math.floor(remaining / 60000);
          const seconds = Math.floor((remaining % 60000) / 1000);
          nextUpdate.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
      }
      
      // Handle chart interaction (mouse or touch)
      function handleChartInteraction(clientX, clientY) {
        if (settings.chartData.length === 0) return;
        
        const rect = mainChart.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        
        const { chartWidth, chartHeight } = getChartDimensions(settings.mainCtx, settings.padding);
        
        if (x >= settings.padding.left && 
            x <= settings.padding.left + chartWidth && 
            y >= settings.padding.top && 
            y <= settings.padding.top + chartHeight) {
          
          const dataIndex = findDataIndexFromX(x, settings.visibleStartIndex, settings.visibleEndIndex, chartWidth, settings.padding.left);
          
          if (dataIndex >= 0 && dataIndex < settings.chartData.length) {
            const dataPoint = settings.chartData[dataIndex];
            
            // Position tooltip
            const tooltipWidth = 200;
            const tooltipHeight = 120;
            let tooltipX = x + 10;
            let tooltipY = y - tooltipHeight - 10;
            
            if (tooltipX + tooltipWidth > rect.width) {
              tooltipX = x - tooltipWidth - 10;
            }
            
            if (tooltipY < 0) {
              tooltipY = y + 10;
            }
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            
            // Update tooltip content
            tooltip.querySelector('.tooltip-date').textContent = formatDate(new Date(dataPoint.timestamp), settings.activeInterval);
            tooltip.querySelector('.tooltip-price').textContent = '$' + formatPrice(dataPoint.price);
            
            const tooltipExtras = tooltip.querySelectorAll('.tooltip-extra');
            tooltipExtras[0].textContent = 'Market Cap: $' + formatLargeNumber(dataPoint.marketCap);
            tooltipExtras[1].textContent = '24h Vol: $' + formatLargeNumber(dataPoint.volume);
            
            // Show tooltip
            tooltip.style.display = 'block';
            
            // Draw vertical line
            drawMainChart(dataIndex);
          }
        } else {
          tooltip.style.display = 'none';
          drawMainChart();
        }
      }
      
      // Handle range handle drag
      function handleRangeHandleDrag(clientX) {
        const rangeRect = rangeSelector.getBoundingClientRect();
        const { chartWidth } = getChartDimensions(settings.rangeCtx, settings.rangePadding);
        const leftBound = rangeRect.left + settings.rangePadding.left;
        const rightBound = leftBound + chartWidth;
        
        let newPos = Math.max(leftBound, Math.min(clientX, rightBound));
        const dataLength = settings.chartData.length;
        
        // Calculate the index based on position
        const percentage = (newPos - leftBound) / chartWidth;
        const newIndex = Math.round(percentage * (dataLength - 1));
        
        if (settings.draggedHandle === 'left') {
          settings.visibleStartIndex = Math.min(newIndex, settings.visibleEndIndex - 1);
        } else {
          settings.visibleEndIndex = Math.max(newIndex, settings.visibleStartIndex + 1);
        }
        
        drawMainChart();
        updateRangeHandles();
      }
      
      // Draw the main chart
      function drawMainChart(hoverIndex = -1) {
        const ctx = settings.mainCtx;
        const { chartWidth, chartHeight } = getChartDimensions(ctx, settings.padding);
        const theme = settings.darkTheme;
        
        // Clear canvas
        ctx.fillStyle = theme.backgroundColor;
        ctx.fillRect(0, 0, mainChart.clientWidth, mainChart.clientHeight);
        
        if (settings.chartData.length === 0) return;
        
        // Determine visible data range
        const visibleData = settings.chartData.slice(settings.visibleStartIndex, settings.visibleEndIndex + 1);
        
        // Find min and max values in visible data
        const priceValues = visibleData.map(d => d.price);
        let minPrice = Math.min(...priceValues);
        let maxPrice = Math.max(...priceValues);
        
        // Add some padding to the min/max
        const pricePadding = (maxPrice - minPrice) * 0.1;
        minPrice = Math.max(0, minPrice - pricePadding);
        maxPrice = maxPrice + pricePadding;
        
        // Draw grid and axes
        drawGrid(ctx, chartWidth, chartHeight, settings.padding, theme);
        drawYAxis(ctx, chartHeight, settings.padding, minPrice, maxPrice, theme);
        drawXAxis(ctx, chartWidth, chartHeight, settings.padding, visibleData, theme, settings.activeInterval);
        
        // Draw price line and fill
        drawPriceLine(ctx, chartWidth, chartHeight, settings.padding, visibleData, minPrice, maxPrice, theme);
        
        // Draw reference line (starting price)
        const startPrice = settings.chartData[0].price;
        if (startPrice >= minPrice && startPrice <= maxPrice) {
          const y = chartHeight - ((startPrice - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.padding.top;
          
          ctx.beginPath();
          ctx.strokeStyle = priceValues[priceValues.length - 1] >= startPrice ? '#10B981' : '#EF4444';
          ctx.setLineDash([5, 5]);
          ctx.moveTo(settings.padding.left, y);
          ctx.lineTo(settings.padding.left + chartWidth, y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw hover indicator
        if (hoverIndex >= 0 && hoverIndex < settings.chartData.length) {
          const dataIndex = hoverIndex - settings.visibleStartIndex;
          
          if (dataIndex >= 0 && dataIndex < visibleData.length) {
            const x = (dataIndex / (visibleData.length - 1)) * chartWidth + settings.padding.left;
            
            // Draw vertical line
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.moveTo(x, settings.padding.top);
            ctx.lineTo(x, settings.padding.top + chartHeight);
            ctx.stroke();
            
            // Draw data point
            const price = visibleData[dataIndex].price;
            const y = chartHeight - ((price - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.padding.top;
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fillStyle = theme.lineColor;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#FFFFFF';
            ctx.stroke();
          }
        }
      }
      
      // Draw the range selector chart
      function drawRangeChart() {
        const ctx = settings.rangeCtx;
        const { chartWidth, chartHeight } = getChartDimensions(ctx, settings.rangePadding);
        const theme = settings.darkTheme;
        
        // Clear canvas
        ctx.fillStyle = theme.backgroundColor;
        ctx.fillRect(0, 0, rangeSelector.clientWidth, rangeSelector.clientHeight);
        
        if (settings.chartData.length === 0) return;
        
        // Find min and max price values
        const priceValues = settings.chartData.map(d => d.price);
        let minPrice = Math.min(...priceValues);
        let maxPrice = Math.max(...priceValues);
        
        // Add some padding to the min/max
        const pricePadding = (maxPrice - minPrice) * 0.1;
        minPrice = Math.max(0, minPrice - pricePadding);
        maxPrice = maxPrice + pricePadding;
        
        // Draw price line and fill
        const points = [];
        for (let i = 0; i < settings.chartData.length; i++) {
          const x = (i / (settings.chartData.length - 1)) * chartWidth + settings.rangePadding.left;
          const y = chartHeight - ((settings.chartData[i].price - minPrice) / (maxPrice - minPrice)) * chartHeight + settings.rangePadding.top;
          points.push({ x, y });
        }
        
        // Draw fill
        ctx.beginPath();
        ctx.moveTo(points[0].x, settings.rangePadding.top + chartHeight);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.lineTo(points[points.length - 1].x, settings.rangePadding.top + chartHeight);
        ctx.closePath();
        ctx.fillStyle = theme.areaColor;
        ctx.fill();
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.strokeStyle = theme.lineColor;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // Draw grid lines and axes background
      function drawGrid(ctx, width, height, padding, theme) {
        const steps = 5;
        
        // Draw background grid
        ctx.strokeStyle = theme.gridColor;
        ctx.lineWidth = 1;
        
        // Horizontal grid lines
        for (let i = 0; i <= steps; i++) {
          const y = padding.top + (height / steps) * i;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + width, y);
          ctx.stroke();
        }
        
        // Vertical grid lines
        const timeSteps = width > 600 ? 6 : 4;
        for (let i = 0; i <= timeSteps; i++) {
          const x = padding.left + (width / timeSteps) * i;
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + height);
          ctx.stroke();
        }
      }
      
      // Draw Y axis (price)
      function drawYAxis(ctx, height, padding, minPrice, maxPrice, theme) {
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.font = '12px sans-serif';
        ctx.fillStyle = theme.textColor;
        
        const steps = 5;
        for (let i = 0; i <= steps; i++) {
          const y = padding.top + (height / steps) * i;
          const price = maxPrice - ((maxPrice - minPrice) / steps) * i;
          ctx.fillText('$' + formatLargeNumber(price), padding.left - 10, y);
        }
      }
      
      // Draw X axis (time)
      function drawXAxis(ctx, width, height, padding, data, theme, interval) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '12px sans-serif';
        ctx.fillStyle = theme.textColor;
        
        const timeSteps = width > 600 ? 6 : 4;
        for (let i = 0; i <= timeSteps; i++) {
          const x = padding.left + (width / timeSteps) * i;
          const dataIndex = Math.floor((i / timeSteps) * (data.length - 1));
          if (dataIndex >= 0 && dataIndex < data.length) {
            const date = new Date(data[dataIndex].timestamp);
            ctx.fillText(formatDateShort(date, interval), x, padding.top + height + 10);
          }
        }
      }
      
      // Draw price line and fill
      function drawPriceLine(ctx, width, height, padding, data, minPrice, maxPrice, theme) {
        const points = [];
        for (let i = 0; i < data.length; i++) {
          const x = (i / (data.length - 1)) * width + padding.left;
          const y = height - ((data[i].price - minPrice) / (maxPrice - minPrice)) * height + padding.top;
          points.push({ x, y });
        }
        
        // Draw fill
        ctx.beginPath();
        ctx.moveTo(points[0].x, padding.top + height);
        for (let i = 0; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.lineTo(points[points.length - 1].x, padding.top + height);
        ctx.closePath();
        
        const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + height);
        gradient.addColorStop(0, 'rgba(247, 147, 26, 0.4)');
        gradient.addColorStop(1, 'rgba(247, 147, 26, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.strokeStyle = theme.lineColor;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Update range selector handles
      function updateRangeHandles() {
        const rangeRect = rangeSelector.getBoundingClientRect();
        const { chartWidth } = getChartDimensions(settings.rangeCtx, settings.rangePadding);
        const dataLength = settings.chartData.length;
        
        // Calculate positions
        const leftPos = (settings.visibleStartIndex / (dataLength - 1)) * chartWidth + settings.rangePadding.left;
        const rightPos = (settings.visibleEndIndex / (dataLength - 1)) * chartWidth + settings.rangePadding.left;
        
        // Update handle positions
        leftHandle.style.left = (leftPos - 4) + 'px';
        rightHandle.style.left = (rightPos - 4) + 'px';
        
        // Update selected range
        rangeSelected.style.left = leftPos + 'px';
        rangeSelected.style.width = (rightPos - leftPos) + 'px';
      }
      
      // Helper function to get chart dimensions
      function getChartDimensions(ctx, padding) {
        const canvas = ctx.canvas;
        const chartWidth = canvas.clientWidth - padding.left - padding.right;
        const chartHeight = canvas.clientHeight - padding.top - padding.bottom;
        return { chartWidth, chartHeight };
      }
      
      // Find data index from x position
      function findDataIndexFromX(x, startIndex, endIndex, chartWidth, leftPadding) {
        const percentage = (x - leftPadding) / chartWidth;
        const range = endIndex - startIndex;
        return Math.round(startIndex + percentage * range);
      }
      
      // Format helpers
      function formatDate(date, interval) {
        if (interval === '1D') {
          return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
        } else if (interval === '7D' || interval === '1M') {
          return date.toLocaleDateString(undefined, { 
            month: 'short', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          });
        } else {
          return date.toLocaleDateString(undefined, { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
        }
      }
      
      function formatDateShort(date, interval) {
        if (interval === '1D') {
          return date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
        } else if (interval === '7D') {
          return date.toLocaleDateString(undefined, { weekday: 'short' });
        } else if (interval === '1M') {
          return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        } else {
          return date.toLocaleDateString(undefined, { month: 'short', year: '2-digit' });
        }
      }
      
      function formatPrice(price) {
        return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }
      
      function formatLargeNumber(num) {
        if (num >= 1e12) {
          return (num / 1e12).toFixed(2) + 'T';
        } else if (num >= 1e9) {
          return (num / 1e9).toFixed(2) + 'B';
        } else if (num >= 1e6) {
          return (num / 1e6).toFixed(2) + 'M';
        } else {
          return num.toLocaleString();
        }
      }
      
      // Throttle function for performance
      function throttle(callback, delay) {
        let lastCall = 0;
        return function(...args) {
          const now = new Date().getTime();
          if (now - lastCall >= delay) {
            lastCall = now;
            callback.apply(this, args);
          }
        };
      }
      
      // Initialize chart on page load
      window.addEventListener('load', initChart);
      
      // Periodic updates (every 5 minutes)
      setInterval(() => {
        if (!cache.get(`chart_${settings.activeInterval}`)) {
          console.log('Cache expired, attempting data refresh...');
          loadChartData(settings.activeInterval);
        }
      }, 5 * 60 * 1000);
      
    })();
  </script>
</body>
</html>
